#!/usr/bin/env bun

/**
 * Version generation script following git versioning best practices
 * Generates version strings in format: v1.2.3-commit[*][-timestamp]
 * Where:
 * - v1.2.3 is from package.json or git tag
 * - commit is short git commit hash
 * - * indicates uncommitted changes
 * - timestamp is added for dirty builds
 */

import fs from 'fs';
import path from 'path';

import { $ } from 'bun';

interface VersionInfo {
  version: string;
  commit: string;
  isDirty: boolean;
  timestamp?: string;
  fullVersion: string;
}

async function getGitInfo(): Promise<{ commit: string; isDirty: boolean }> {
  try {
    // Get short commit hash
    const commitResult = await $`git rev-parse --short HEAD`.quiet();
    const commit = commitResult.stdout.toString().trim();

    // Check if working directory is dirty
    const statusResult = await $`git status --porcelain`.quiet();
    const isDirty = statusResult.stdout.toString().trim().length > 0;

    return { commit, isDirty };
  } catch (error) {
    console.warn('Git not available, using fallback values');
    return { commit: 'unknown', isDirty: false };
  }
}

function getPackageVersion(): string {
  try {
    const packagePath = path.join(process.cwd(), 'package.json');
    const packageJson = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
    return packageJson.version;
  } catch (error) {
    console.warn('Could not read package.json version, using 0.0.0');
    return '0.0.0';
  }
}

function generateTimestamp(): string {
  return new Date()
    .toISOString()
    .replace(/[-:]/g, '')
    .replace(/\.\d{3}Z$/, '');
}

async function generateVersionInfo(): Promise<VersionInfo> {
  const baseVersion = getPackageVersion();
  const { commit, isDirty } = await getGitInfo();
  const timestamp = isDirty ? generateTimestamp() : undefined;

  let fullVersion = `v${baseVersion}-${commit}`;
  if (isDirty) {
    fullVersion += '*';
    if (timestamp) {
      fullVersion += `-${timestamp}`;
    }
  }

  return {
    version: baseVersion,
    commit,
    isDirty,
    timestamp,
    fullVersion,
  };
}

async function writeVersionFile(versionInfo: VersionInfo): Promise<void> {
  const versionFileContent = `// This file is auto-generated by scripts/generate-version.ts
// Do not edit manually - it will be overwritten on build

export const VERSION_INFO = {
  version: '${versionInfo.version}',
  commit: '${versionInfo.commit}',
  isDirty: ${versionInfo.isDirty},
  timestamp: ${versionInfo.timestamp ? `'${versionInfo.timestamp}'` : 'undefined'},
  fullVersion: '${versionInfo.fullVersion}',
  buildTime: '${new Date().toISOString()}',
} as const;

export const getBuildVersion = () => VERSION_INFO.fullVersion;
`;

  const outputPath = path.join(process.cwd(), 'src', 'version.ts');
  fs.writeFileSync(outputPath, versionFileContent, 'utf8');
  console.log(`Generated version file: ${outputPath}`);
  console.log(`Build version: ${versionInfo.fullVersion}`);
}

async function updateManifestVersion(versionInfo: VersionInfo): Promise<void> {
  try {
    const manifestPath = path.join(process.cwd(), 'manifest.json');
    const manifestContent = fs.readFileSync(manifestPath, 'utf8');
    const manifest = JSON.parse(manifestContent);

    // Use full version for development builds, base version for clean builds
    const manifestVersion = versionInfo.isDirty ? versionInfo.fullVersion : versionInfo.version;

    if (manifest.version !== manifestVersion) {
      manifest.version = manifestVersion;
      fs.writeFileSync(manifestPath, JSON.stringify(manifest, null, 2) + '\n', 'utf8');
      console.log(`Updated manifest.json version to: ${manifestVersion}`);
    } else {
      console.log(`Manifest version already correct: ${manifestVersion}`);
    }
  } catch (error) {
    console.warn('Could not update manifest.json version:', error);
  }
}

// Main execution
async function main() {
  try {
    const versionInfo = await generateVersionInfo();
    await writeVersionFile(versionInfo);
    await updateManifestVersion(versionInfo);
  } catch (error) {
    console.error('Failed to generate version:', error);
    process.exit(1);
  }
}

if (import.meta.main) {
  main();
}
